<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0"
    />
    <title>Lightweight Charts™ Customization Tutorial</title>
    <!-- Adding the standalone version of Lightweight charts -->
   
    <script
      type="text/javascript"
      src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  

    <style>
      body {
        padding: 0;
        margin: 0;
        /* Add a background color to match the chart */
        /*background-color:#222;*/
      }
    </style>
  </head>

  <body>
    <div
      id="container"
      style="position: absolute; width: 100%; height: 100%"
    ></div>
    <script type="text/javascript">
        import { createChart } from 'lightweight-charts';

        // We will use the Fetch API to get the CSV file and PapaParse library to parse it into JSON
        /*
        fetch('https://cors-anywhere.herokuapp.com/http://lilibtc.com/wp-content/uploads/2023/04/1681120515-9f5e7a7288076bb.csv', {
          headers: {
            'Origin': 'https://lilibtc.com' // Replace with your website's domain
          }
        })
        */
      // Note: You will need to include the PapaParse library in your HTML file for this code to work.
      fetch("http://127.0.0.1:8080/WebServer/bitcoin-marketcap-residual-week.csv")// https://lilibtc.com/wp-content/uploads/2023/04/1681120515-9f5e7a7288076bb.csv
        .then(response => response.text()) // Get the text from the response
        .then(csvText => Papa.parse(csvText, { header: true })) // Parse the text into JSON with headers
        .then(jsonData => {
          // Use the jsonData here
          console.log(jsonData)
        })
        .catch(error => console.error(error)); // Handle any errors that occur during the process
       // 读出jsonData，并组合成"Bitcoin-MarketCap-Log"和"Residual"Series数据
       // Use the map function to create two new arrays, one for Bitcoin-MarketCap-Log-SeriesData and one for Residual-SeriesData
      const BitcoinMarketCapLogSeriesData = jsonData.map(item => ({ time: item.time, value: item['Bitcoin-MarketCap-Log'] }));
      const ResidualSeriesData = jsonData.map(item => ({ time: item.time, value: item.Residual }));
        
      // Function to generate a sample set of Area datapoints
      function generateBitcoinMarketCapLogSeriesData() {
        return BitcoinMarketCapLogSeriesData
      }

      function generateResidualSeriesData() {
        return ResidualSeriesData
      }
      // Create the Lightweight Chart within the container element
      const chart = LightweightCharts.createChart(
        document.getElementById('container'),
          {
            layout: {
                background: { color: 'white' },
                textColor: 'black',//#DDD
            },
            grid: {
                vertLines: { color: '#444' },
                horzLines: { color: '#444' },
            },
            height: 400,
            width: 700,
          }
      );

      // Generate sample data to use within a candlestick series
      const candleStickData = generateCandlestickData().map(datapoint => {
          // map function is changing the color for the individual
          // candlestick points that close above 205
          if (datapoint.close < 205) { return datapoint; }
          // we are adding 'color' and 'wickColor' properties to the datapoint.
          // Using spread syntax: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals
          return { ...datapoint, color: 'orange', wickColor: 'orange' };
      });
      // Convert the candlestick data for use with a line series
      const lineData = candleStickData.map(datapoint => ({
          time: datapoint.time,
          value: (datapoint.close + datapoint.open) / 2,
      }));
      // Add an area series to the chart,
      // Adding this before we add the candlestick chart
      // so that it will appear beneath the candlesticks
      const areaSeries = chart.addAreaSeries({
          lastValueVisible: false, // hide the last value marker for this series
          crosshairMarkerVisible: false, // hide the crosshair marker for this series
          lineColor: '#DDD', // hide the line
          topColor: 'rgba(56, 33, 110,0.6)',
          bottomColor: 'rgba(56, 33, 110, 0.1)',
      });
      // Set the data for the Area Series
      areaSeries.setData(lineData);
      // Create the Main Series (Candlesticks)
      const mainSeries = chart.addCandlestickSeries();
      // Set the data for the Main Series
      mainSeries.setData(candleStickData);
      // Setting the border color for the vertical axis
      chart.priceScale().applyOptions({
          borderColor: '#71649C',
      });

      // Setting the border color for the horizontal axis
      chart.timeScale().applyOptions({
          borderColor: '#71649C',
          barSpacing: 10,
      });
      chart.timeScale().fitContent();
      // Adding a window resize event handler to resize the chart when
      // the window size changes.
      // Note: for more advanced examples (when the chart doesn't fill the entire window)
      // you may need to use ResizeObserver -> https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
      //window.addEventListener("resize", () => {
      //  chart.resize(window.innerWidth, window.innerHeight);
      //});
      // Get the current users primary locale
      const currentLocale = window.navigator.languages[0];
      // Create a number format using Intl.NumberFormat
      const myPriceFormatter = Intl.NumberFormat(currentLocale, {
          style: 'currency',
          currency: 'USD', // Currency for data points
      }).format;
      // Apply the custom priceFormatter to the chart
      chart.applyOptions({
          localization: {
              priceFormatter: myPriceFormatter,
          },
      });
      // Customizing the Crosshair
      chart.applyOptions({
          crosshair: {
              // Change mode from default 'magnet' to 'normal'.
              // Allows the crosshair to move freely without snapping to datapoints
              mode: LightweightCharts.CrosshairMode.Normal,

              // Vertical crosshair line (showing Date in Label)
              vertLine: {
                  width: 8,
                  color: '#C3BCDB44',
                  style: LightweightCharts.LineStyle.Solid,
                  labelBackgroundColor: '#9B7DFF',
              },

              // Horizontal crosshair line (showing Price in Label)
              horzLine: {
                  color: '#9B7DFF',
                  labelBackgroundColor: '#9B7DFF',
              },
          },
      });
      // Changing the Candlestick colors
      mainSeries.applyOptions({
          wickUpColor: 'rgb(54, 116, 217)',
          upColor: 'rgb(54, 116, 217)',
          wickDownColor: 'rgb(225, 50, 85)',
          downColor: 'rgb(225, 50, 85)',
          borderVisible: false,
      });
      // Adjust the options for the priceScale of the mainSeries
      mainSeries.priceScale().applyOptions({
          autoScale: true, // disables auto scaling based on visible content
          scaleMargins: {
              top: 0.1,
              bottom: 0.2,
          },
      });
      // add price line
      const myPriceLine = {
        price: 160,
        color: '#3179F5',
        lineWidth: 2,
        lineStyle: 2, // LineStyle.Dashed
        axisLabelVisible: true,
        title: '买入提示',
      };
      mainSeries.createPriceLine(myPriceLine);
      // add marker
      const markers = [
          {
              time: { year: 2019, month: 4, day: 23 },
              position: 'aboveBar',
              color: '#f68410',
              shape: 'arrowDown',
              text: '卖出',
          },
      ];
      mainSeries.setMarkers(markers);
      
      // add legend
      const symbolName = '以太坊价格-美元 ';

      const container = document.getElementById('container');

      const legend = document.createElement('div');
      legend.style = "position: absolute; left: 12px; top: 12px; z-index: 1; font-size: 14px; font-family: sans-serif; line-height: 18px; font-weight: 300";
      container.appendChild(legend);

      const firstRow = document.createElement('div');
      firstRow.innerHTML = symbolName;
      firstRow.style.color = 'black';
      legend.appendChild(firstRow);

      // add a tooltip
      const toolTip = document.createElement('div');
      toolTip.style = `width: 96px; height: 80px; position: absolute; display: none; padding: 8px; box-sizing: border-box; font-size: 12px; text-align: left; z-index: 1000; top: 12px; left: 12px; pointer-events: none; border: 1px solid; border-radius: 2px;font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;`;
      toolTip.style.background = 'white';
      toolTip.style.color = 'black';
      toolTip.style.borderColor = '#2962FF';
      container.appendChild(toolTip);

      chart.subscribeCrosshairMove(param => {
          let priceFormatted = '';
          if (param.time) {
              const dateStr = param.time;
              const data = param.seriesData.get(mainSeries);
              const price = data.value !== undefined ? data.value : data.close;
              priceFormatted = price.toFixed(2);
              toolTip.style.display = 'block';
              toolTip.innerHTML = `<div>${priceFormatted}</div>
              <div>${dateStr}</div>`;
              // Position tooltip according to mouse cursor position
              toolTip.style.left = param.point.x - 50 + 'px';
              toolTip.style.top = param.point.y - 50 + 'px';

          }
          firstRow.innerHTML = `${symbolName} <strong>`;
          /*
          ${priceFormatted}</strong>`;
          if (
              param.point === undefined ||
              !param.time ||
              param.point.x < 0 ||
              param.point.y < 0
          ) {
              toolTip.style.display = 'none';
          } else {
              const dateStr = dateToString(param.time);
              const data = param.seriesData.get(mainSeries);
              const price = data.value !== undefined ? data.value : data.close;

          }
          
      });
      */
    </script>
  </body>
</html>
